package RISCV.utils

import scala.collection.mutable.{Queue, Set => MutableSet}

object PermBuilder {

  def mapToArray(p: Map[Int, Int]): Array[Int] = {
    val arr = Array.tabulate(32)(i => i)
    p.foreach { case (dest, src) => arr(dest) = src }
    arr
  }

  def arrayToMap(arr: Array[Int]): Map[Int, Int] = {
    arr.zipWithIndex.map { case (src, dest) => dest -> src }.toMap
  }

  def isId(p: Array[Int]): Boolean = {
    (0 until 32).forall(i => p(i) == i)
  }

  def isRot(p: Array[Int]): Option[Int] = {
    val possShifts = (0 until 32).map { i =>
      (p(i) - i + 32) % 32
    }
    val firstShift = possShifts(0)
    if (possShifts.forall(_ == firstShift)) {
      Some(firstShift)
    } else { None }
  }

  def doTransform(curr: Array[Int], transform: String): Array[Int] = {
    val newArr = Array.fill(32)(0)

    def applyGrevi(i: Int, imm: Int): Int = {
      var idx = i
      if ((imm & (1 << 0)) != 0) idx = if (idx % 2 == 0) idx + 1 else idx - 1
      if ((imm & (1 << 1)) != 0) idx = if ((idx % 4) < 2) idx + 2 else idx - 2
      if ((imm & (1 << 2)) != 0) idx = if ((idx % 8) < 4) idx + 4 else idx - 4
      if ((imm & (1 << 3)) != 0) idx = if ((idx % 16) < 8) idx + 8 else idx - 8
      if ((imm & (1 << 4)) != 0) idx = if (idx < 16) idx + 16 else idx - 16
      idx
    }

    def applyShfli(i: Int, imm: Int): Int = {
      var idx = i
      if ((imm & (1 << 0)) != 0) idx = (idx % 4) match {
        case 1 => idx + 1
        case 2 => idx - 1
        case _ => idx
      }
      if ((imm & (1 << 1)) != 0) idx = (idx % 8 / 2) match {
        case 1 => idx + 2
        case 2 => idx - 2
        case _ => idx
      }
      if ((imm & (1 << 2)) != 0) idx = (idx % 16 / 4) match {
        case 1 => idx + 4
        case 2 => idx - 4
        case _ => idx
      }
      if ((imm & (1 << 3)) != 0) idx = (idx % 32 / 8) match {
        case 1 => idx + 8
        case 2 => idx - 8
        case _ => idx
      }
      idx
    }

    def applyUnshfli(i: Int, imm: Int): Int = {
      var idx = i
      if ((imm & (1 << 3)) != 0) idx = (idx % 32 / 8) match {
        case 1 => idx + 8
        case 2 => idx - 8
        case _ => idx
      }
      if ((imm & (1 << 2)) != 0) idx = (idx % 16 / 4) match {
        case 1 => idx + 4
        case 2 => idx - 4
        case _ => idx
      }
      if ((imm & (1 << 1)) != 0) idx = (idx % 8 / 2) match {
        case 1 => idx + 2
        case 2 => idx - 2
        case _ => idx
      }
      if ((imm & (1 << 0)) != 0) idx = (idx % 4) match {
        case 1 => idx + 1
        case 2 => idx - 1
        case _ => idx
      }
      idx
    }

    val imm = extractImm(transform)
    if (transform.startsWith("rori")) {
      for (i <- 0 until 32) newArr(i) = curr((i + imm) % 32)
    } else if (transform.startsWith("grevi")) {
      for (i <- 0 until 32) newArr(i) = curr(applyGrevi(i, imm))
    } else if (transform.startsWith("shfli")) {
      for (i <- 0 until 32) newArr(i) = curr(applyShfli(i, imm))
    } else if (transform.startsWith("unshfli")) {
      for (i <- 0 until 32) newArr(i) = curr(applyUnshfli(i, imm))
    } else {
      return curr.clone()
    }

    newArr
  }


  def extractImm(instr: String): Int = {
    val parts = instr.split(" ")
    if (parts.length >= 4) {
      val immStr = parts(3).trim
      if (immStr.startsWith("0x")) {
        Integer.parseInt(immStr.substring(2), 16)
      } else { immStr.toInt }
    } else 0
  }

  def detectSpecialPatterns(perm: Map[Int, Int]): Option[String] = {
    val arr = mapToArray(perm)
  
    if ((0 until 32 by 2).forall(i => arr(i) == i+1 && arr(i+1) == i)) {
      return Some("grevi x1, x1, 0x1")
    }
    
    if ((0 until 32 by 4).forall(i => arr(i) == i+2 && arr(i+1) == i+3 && arr(i+2) == i && arr(i+3) == i+1)) {
      return Some("grevi x1, x1, 0x2")
    }

    if ((0 until 32 by 8).forall(i => (0 until 4).forall(j => arr(i+j) == i+j+4 && arr(i+j+4) == i+j))) {
      return Some("grevi x1, x1, 0x4")
    }

    if ((0 until 32 by 16).forall(i => (0 until 8).forall(j => arr(i+j) == i+j+8 && arr(i+j+8) == i+j))) {
      return Some("grevi x1, x1, 0x8")
    }
    
    if ((0 until 16).forall(i => arr(i) == i+16 && arr(i+16) == i)) {
      return Some("grevi x1, x1, 0x10")
    }
    
    None
  }

  def getInstrBFS(rd: Int, initialState: Array[Int], targetState: Array[Int], maxDepth: Int): Option[List[String]] = {
    if (initialState.sameElements(targetState)) return Some(List())
    
    val visited = MutableSet[String]()
    val queue = Queue((initialState, List[String]()))
    visited.add(initialState.mkString(","))
    
    val roriImms = List(2, 31, 30, 1, 4, 8, 16, 28, 24, 15)
    val shfliUnshfliImms = List(0x1f, 0x1, 0x2, 0x4, 0x8, 0x10, 0x3, 0x5, 0x6, 0x7, 0xf)
    val greviImms = List(0x1, 0x2, 0x4, 0x8, 0x10, 0x3, 0x5, 0x6, 0x7, 0xf, 0x1f)

    val roriCands = roriImms.map(imm => s"rori x$rd x$rd $imm")
    val shfliCands = shfliUnshfliImms.map(imm => s"shfli x$rd x$rd 0x${imm.toHexString}")
    val unshfliCands = shfliUnshfliImms.map(imm => s"unshfli x$rd x$rd 0x${imm.toHexString}")
    val greviCands = greviImms.map(imm => s"grevi x$rd x$rd 0x${imm.toHexString}")
    
    val allCands = roriCands ++ unshfliCands ++ shfliCands ++ greviCands

    while (queue.nonEmpty) {
      val (currArr, instrList) = queue.dequeue()

      if (instrList.length < maxDepth) {
        for (cand <- allCands) {
          val newCurrArr = doTransform(currArr, cand)
          val stateKey = newCurrArr.mkString(",")
          
          if (!visited.contains(stateKey)) {
            visited.add(stateKey)
            val newInstrList = instrList :+ cand
            
            if (newCurrArr.sameElements(targetState)) {
              return Some(newInstrList)
            }
            
            queue.enqueue((newCurrArr, newInstrList))
          }
        }
      }
    }
    None
  }

  def buildPermutation(rd: Int, rs1: Int, perm: Map[Int, Int]): List[String] = {
    val targetArr = mapToArray(perm)
    val identArr = Array.tabulate(32)(i => i)

    if (isId(targetArr)) {
      return List() // return grevi with 0 or 2 times grevi with 31
    }

    isRot(targetArr) match {
      case Some(rotAmount) =>
        return List(s"rori x$rd x$rd $rotAmount")
      case None =>
    }

    detectSpecialPatterns(perm) match {
      case Some(instr) => 
        return List(instr.replace("x1", s"x$rd"))
      case None =>
    } // include common shfli and common unsfli pattern too

    for (depth <- 1 to 4) {
      getInstrBFS(rd, identArr, targetArr, depth) match {
        case Some(res) => return res
        case None =>
      }
    }
    
    List() // [instrs] source Permutation ---> rendevous permutation <--- target Permutation [instrs] => [instrs] + [instrs].reversed 
  }
}